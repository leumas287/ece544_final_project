# robot_controller.py
#   Design using Diglient/Xilinx PYNQ infrastructure to control a 4 wheeled robot with a gripper claw.
#   The motors that drive the wheels are controlled using GPIO signals to drive the motor Enable/Direction
#   A Digilent PMOD DHB3 is connected to the PMODA connector of the PYNQ board, using pins 0,1,4,5 as
#   Outputs used to control the movement of the robot.  The duration of a write controls the distance forward or
#   Backward the robot moves and the degree to which the robot rotates when turning left/right.  The 
#    PYNQ pmod_grove_buzzer example was used as inspiration for the motor control logic.
#    The PMODB pin0 is connected to the PWM signal of the gripper arm servo, allowing the gripper to be opened
#    and closed from the PYNQ PWM signal generated by an AXI Timer.  The pmod_pwm example from the PYNQ
#    repository provided inspiration for this design.

# There are certainly other ways to design the control of a robot with this setup and implement additional functionality.
# If a custom module were implemented to replace the IOP structure of the PMODA/B or extended to allow for 
# multiple PWM pins and a combination of GPIO input/output and PWM signals, the full DHB1 device could have been fully
# supported.  Due to limited time and resources the design was simplified utilizing the robust set of default configurations
# the PYNQ offers.

__author__      = "Samuel K Burkhar"
__copyright__   = "Copyright 2017, PSU"
__email__       = "samuel.burkhart@gmail.com"


import time
from pynq import Overlay
from pynq.iop import Pmod_PWM
from pynq.iop import Pmod_IO
from pynq.iop import PMODA
from pynq.iop import PMODB

class Robot_Controller(object):
    def __init__(self):
        Overlay("base.bit").download()
        
        # Setup the PMODA pins as GPIO outputs for the Enable and Direction signals for the Digilent PMOD DHB1
        # The pins for the DHB1 are as follows:
        #   - Pin0: Enable1 (output)
        #   - Pin1: Direction1 (output)
        #   - Pin2: SA_1 (input, not used)
        #   - Pin3: SB_1 (input, not used)
        #   - Pin4: Enable2 (output)
        #   - Pin5: Direction2 (output)
        #   - Pin6: SA_2 (input, not used)
        #   - Pin7: SB_2 (input, not used)
        self.right_enable = Pmod_IO(PMODA, 0, 'out')
        self.right_direction = Pmod_IO(PMODA, 1, 'out')
        self.left_enable = Pmod_IO(PMODA, 4, 'out')
        self.left_direction = Pmod_IO(PMODA, 5, 'out')
        
        # Setup the gripper arm (servo) to be driven by the PmodB pin1 as a PWM pin
        self.gripper_pwm = Pmod_PWM(PMODB, 0)
        
        # The Pmod_PWM constructor sets a fixed PWM signal, stop it to reduce load on the servo
        self.gripper_pwm.stop()
        
    def left(self, duration=0.1):
        # Stop the motor's before changing direction
        self.left_enable.write(0)
        self.right_enable.write(0)
        
        # Change direction to "reverse"
        self.left_direction.write(0)
        self.right_direction.write(0)
        
        # Go forward
        self.left_enable.write(1)
        self.right_enable.write(1)
        
        # Wait for one second
        time.sleep(duration)
        
        # Stop the motor
        self.right_enable.write(0)
        self.left_enable.write(0)
        
    def right(self, duration=0.1):
        # Stop the motor's before changing direction
        self.left_enable.write(0)
        self.right_enable.write(0)
        
        # Change direction to "forward"
        self.left_direction.write(1)
        self.right_direction.write(1)
        
        # Go forward
        self.left_enable.write(1)
        self.right_enable.write(1)
        
        # Wait for one second
        time.sleep(duration)
        
        # Stop the motor
        self.right_enable.write(0)
        self.left_enable.write(0) 
        
    def forward(self, duration=0.1):
        # Stop the motor's before changing direction
        self.left_enable.write(0)
        self.right_enable.write(0)
        
        # Change direction to "forward"
        self.right_direction.write(1)
        self.left_direction.write(0)
        
        
        # Go forward
        self.left_enable.write(1)
        self.right_enable.write(1)
        
        # Wait for one second
        time.sleep(duration)
        
        # Stop the motor
        self.right_enable.write(0)
        self.left_enable.write(0)
        
    def reverse(self, duration=0.1):
        # Stop the motor's before changing direction
        self.left_enable.write(0)
        self.right_enable.write(0)
        
        # Change direction to "right"
        self.right_direction.write(0)
        self.left_direction.write(1)
        
        
        # Go forward
        self.left_enable.write(1)
        self.right_enable.write(1)
        
        # Wait for one second
        time.sleep(duration)
        
        # Stop the motor
        self.right_enable.write(0)
        self.left_enable.write(0)
        
    # Function to close the gripper, "gripping" an object
    def grip(self):
        # Set the period to 25ms for the servo
        period = 25000
        
        # Set the duty cycle to 1% = 25ms * 0.01 = 500us
        # This corresponds to 0 degree's on the servo
        # or a closed gripper arm position
        duty = 1
        
        # output the signal to the servo gripper arm to "grip"
        self.gripper_pwm.generate(period, duty)
    
    def release(self):
        # Set the period to 25ms for the servo
        period = 25000
        
        # Set the duty cycle to 3% = 25ms * 0.03 = 750us pulse
        # This corresponds to 0 degree's on the servo
        # or an open gripper arm position
        duty = 4
        
        # output the signal to the servo gripper arm to "release"
        self.gripper_pwm.generate(period, duty)
        time.sleep(0.3)
        self.gripper_pwm.stop()
        